# v3.7.0 Implementation Plan: Master/Slave Architecture

## Executive Summary

v3.7.0 represents a **major architectural shift** from a standalone GUI application to a distributed master/slave system. This document analyzes the goals, identifies critical pre-requisites, and provides a phased implementation roadmap.

**Risk Assessment:** HIGH - This is the most complex release to date. Without proper foundation work, debugging distributed systems will be extremely difficult.

**Deployment Target:**
- **Master:** Windows (GUI application)
- **Slave:** Debian/Ubuntu Linux servers (headless, systemd-managed)

---

## Part 1: Analysis of v3.7.0 Goals

### 1.1 Feature Breakdown

| Feature | Complexity | Dependencies | Risk |
|---------|------------|--------------|------|
| Key Exchange (RSA/Secret Key) | Medium | cryptography library | Medium |
| Headless Client (slave.py) | High | Config system | High |
| SSH Scanner | Medium | asyncssh | High (security) |
| RDP Scanner | Low | stdlib only (TPKT/X.224) | High (security) |
| Master GUI Page | Medium | Existing page pattern | Low |
| Data Sync (WebSockets) | High | websockets library | High |
| Error Handling | Medium | Logging infrastructure | Medium |
| Configuration | Medium | Settings system | Low |
| Testing | High | pytest, mocking | Medium |
| Deployment | Low | Documentation only | Low |

### 1.2 Current Architecture Gaps

Based on codebase exploration, these gaps must be addressed:

```
CRITICAL GAPS:
├── No networking layer (WebSocket/RPC)
├── No authentication system
├── No encryption for credentials
├── No test infrastructure (0 tests exist)
├── No file-based logging (slaves need logs)
└── Settings stored plaintext (security risk for distributed)

EXISTING STRENGTHS:
├── Callback architecture (on_update, on_log) - extendable
├── Modular page system - easy to add Master GUI
├── Data models (TrafficConfig, TrafficStats) - serializable
├── Thread-safe Queue pattern - proven
└── Atomic file persistence - reliable
```

### 1.3 Security Considerations

The SSH/RDP Scanner feature requires careful implementation:

```
REQUIRED SAFEGUARDS:
1. Explicit authorization prompts (like Stress Test)
2. Rate limiting on credential attempts
3. Logging of all scan activities
4. No default wordlists shipped (user must provide)
5. Target whitelist/blacklist support
6. Legal disclaimer acceptance before first use
```

---

## Part 2: Pre-v3.7.0 Requirements (v3.6.5)

### 2.1 CRITICAL: Testing Infrastructure

**Why:** Distributed systems are notoriously hard to debug. Without tests, issues will compound.

**Scope:**
```
tests/
├── __init__.py
├── conftest.py              # Pytest fixtures
├── test_models.py           # Data model serialization
├── test_validators.py       # Proxy validation logic
├── test_utils.py            # Settings, safe_int, URL validation
├── test_proxy_manager.py    # Scraping, deduplication
└── test_engine.py           # Engine callback contracts
```

**Minimum Coverage:**
- `Utils.validate_url()` - 10 test cases
- `Utils.safe_int()` - 8 test cases
- `Utils.deduplicate_proxies()` - 5 test cases
- `ProxyConfig.to_curl_cffi_format()` - 6 test cases
- `TrafficConfig` serialization - 4 test cases
- Validator response parsing - 6 validators × 3 cases each

**Estimated Effort:** 2-3 focused sessions

### 2.2 SIMPLIFIED: Logging (systemd handles this)

**Why:** Linux slaves run under systemd, which captures stdout/stderr to journalctl automatically.

**No custom logging infrastructure needed for slaves.** Just use:
- `print()` or `logging.StreamHandler()` → systemd captures to journal
- View logs: `journalctl -u dm-slave -f`
- Filter by time: `journalctl -u dm-slave --since "1 hour ago"`

**Implementation (minimal):**
```python
# core/logging_config.py (NEW - simple)
import logging
import sys

def setup_logging(
    name: str = "dm-slave",
    level: int = logging.INFO,
) -> logging.Logger:
    """Configure logging for systemd (stdout only)."""
    logger = logging.getLogger(name)
    logger.setLevel(level)

    # systemd captures stdout, so just use StreamHandler
    handler = logging.StreamHandler(sys.stdout)
    handler.setFormatter(logging.Formatter(
        "%(levelname)-8s | %(name)s | %(message)s"
    ))
    logger.addHandler(handler)

    return logger
```

**Benefits of systemd journalctl:**
- Automatic log rotation (no disk fill)
- Persistent across restarts
- Structured querying
- Centralized with other system logs
- Zero configuration

**Estimated Effort:** 0.5 session (just wire up stdlib logging)

### 2.3 HIGH: Configuration System Enhancement

**Why:** Distributed systems need secure credential handling and environment variable support.

**Changes to `ui/utils.py`:**
```python
import os

class Utils:
    @staticmethod
    def load_settings(filename="resources/settings.json") -> dict:
        defaults = {...}

        # Load from file
        if os.path.exists(filename):
            with open(filename) as f:
                file_settings = json.load(f)
                defaults.update(file_settings)

        # Environment variable overrides (NEW)
        env_mappings = {
            "DM_CAPTCHA_2CAPTCHA_KEY": "captcha_2captcha_key",
            "DM_CAPTCHA_ANTICAPTCHA_KEY": "captcha_anticaptcha_key",
            "DM_MASTER_HOST": "master_host",
            "DM_MASTER_PORT": "master_port",
            "DM_SLAVE_SECRET": "slave_secret_key",
        }
        for env_var, setting_key in env_mappings.items():
            if env_val := os.environ.get(env_var):
                defaults[setting_key] = env_val

        return defaults
```

**New Settings for v3.7.0:**
```json
{
    "mode": "standalone",           // "standalone", "master", "slave"
    "master_host": "127.0.0.1",
    "master_port": 8765,
    "slave_secret_key": "",         // Shared secret for authentication
    "slave_name": "slave-01",       // Human-readable slave identifier
    "heartbeat_interval": 10,       // Seconds between heartbeats
    "auto_reconnect": true,
    "reconnect_delay": 5
}
```

**Estimated Effort:** 1 session

### 2.4 MEDIUM: Complete Proxy Chaining (In Progress)

**Why:** Slaves may need to route traffic through master's proxy for anonymity.

**Current Status:** Listed as "In Progress" in todo.md

**Recommendation:** Complete this before v3.7.0 as it provides infrastructure for slave proxy routing.

---

## Part 3: v3.7.0 Implementation Phases

### Phase 1: Communication Layer (Foundation)

**Duration:** 2-3 sessions

**New Files:**
```
core/
├── network/
│   ├── __init__.py
│   ├── protocol.py          # Message format definitions
│   ├── server.py            # WebSocket server (master)
│   ├── client.py            # WebSocket client (slave)
│   └── auth.py              # Key exchange & authentication
```

**Message Protocol:**
```python
# core/network/protocol.py
from dataclasses import dataclass, asdict
from enum import Enum
from typing import Any, Optional
import json

class MessageType(Enum):
    # Connection management
    HELLO = "hello"              # Slave -> Master: Initial connection
    WELCOME = "welcome"          # Master -> Slave: Accept + config
    HEARTBEAT = "heartbeat"      # Bidirectional: Keep-alive
    GOODBYE = "goodbye"          # Either: Clean disconnect

    # Configuration
    CONFIG_PUSH = "config_push"  # Master -> Slave: Update config
    CONFIG_ACK = "config_ack"    # Slave -> Master: Config applied

    # Task management
    TASK_ASSIGN = "task_assign"  # Master -> Slave: Start task
    TASK_STATUS = "task_status"  # Slave -> Master: Progress update
    TASK_COMPLETE = "task_complete"  # Slave -> Master: Task done
    TASK_ERROR = "task_error"    # Slave -> Master: Task failed

    # Stats reporting
    STATS_UPDATE = "stats_update"  # Slave -> Master: Traffic stats

    # Scanner (v3.7.0 specific)
    SCAN_REQUEST = "scan_request"    # Master -> Slave: Start scan
    SCAN_RESULT = "scan_result"      # Slave -> Master: Found host
    SCAN_COMPLETE = "scan_complete"  # Slave -> Master: Scan done

@dataclass
class Message:
    type: MessageType
    payload: dict
    node_id: Optional[str] = None
    timestamp: Optional[float] = None

    def to_json(self) -> str:
        return json.dumps({
            "type": self.type.value,
            "payload": self.payload,
            "node_id": self.node_id,
            "timestamp": self.timestamp or time.time(),
        })

    @classmethod
    def from_json(cls, data: str) -> "Message":
        obj = json.loads(data)
        return cls(
            type=MessageType(obj["type"]),
            payload=obj["payload"],
            node_id=obj.get("node_id"),
            timestamp=obj.get("timestamp"),
        )
```

**Authentication Flow:**
```
1. Slave connects to Master WebSocket
2. Slave sends HELLO with node_id + HMAC(timestamp, secret_key)
3. Master verifies HMAC, sends WELCOME with session_token
4. All subsequent messages include session_token in header
5. Invalid token -> connection dropped
```

**Dependencies:**
```
# Add to requirements.txt
websockets>=12.0
cryptography>=41.0.0
```

### Phase 2: Headless Client (slave.py)

**Duration:** 2 sessions

**Entry Point:**
```python
# slave.py (NEW - root level)
#!/usr/bin/env python3
"""
DarkMatter Traffic Bot - Slave Node
Headless client for distributed traffic generation.

Usage:
    python slave.py --master 192.168.1.100:8765 --name slave-01
    python slave.py --config slave_config.json

Environment Variables:
    DM_MASTER_HOST      Master server hostname/IP
    DM_MASTER_PORT      Master server port (default: 8765)
    DM_SLAVE_SECRET     Shared authentication secret
    DM_SLAVE_NAME       This node's identifier
"""
import argparse
import asyncio
import signal
import sys
from pathlib import Path

from core.logging_config import setup_logging
from core.network.client import SlaveClient
from ui.utils import Utils

def parse_args():
    parser = argparse.ArgumentParser(description="DarkMatter Slave Node")
    parser.add_argument("--master", "-m", help="Master address (host:port)")
    parser.add_argument("--name", "-n", help="Slave node name")
    parser.add_argument("--secret", "-s", help="Authentication secret")
    parser.add_argument("--config", "-c", help="Config file path")
    parser.add_argument("--log-level", default="INFO",
                        choices=["DEBUG", "INFO", "WARNING", "ERROR"])
    return parser.parse_args()

async def main():
    args = parse_args()

    # Setup logging (file-only for headless)
    logger = setup_logging(
        name="dm-slave",
        level=getattr(logging, args.log_level),
        console=True,  # Can be disabled for daemon mode
    )

    # Load settings
    settings = Utils.load_settings()

    # CLI overrides
    if args.master:
        host, port = args.master.rsplit(":", 1)
        settings["master_host"] = host
        settings["master_port"] = int(port)
    if args.name:
        settings["slave_name"] = args.name
    if args.secret:
        settings["slave_secret_key"] = args.secret

    # Validate required settings
    if not settings.get("master_host"):
        logger.error("Master host not specified. Use --master or DM_MASTER_HOST")
        sys.exit(1)
    if not settings.get("slave_secret_key"):
        logger.error("Secret key not specified. Use --secret or DM_SLAVE_SECRET")
        sys.exit(1)

    # Create and run slave client
    client = SlaveClient(settings, logger)

    # Handle graceful shutdown
    loop = asyncio.get_event_loop()
    for sig in (signal.SIGINT, signal.SIGTERM):
        loop.add_signal_handler(sig, lambda: asyncio.create_task(client.shutdown()))

    try:
        await client.run()
    except KeyboardInterrupt:
        logger.info("Shutdown requested")
    finally:
        await client.cleanup()

if __name__ == "__main__":
    asyncio.run(main())
```

**SlaveClient Class:**
```python
# core/network/client.py
class SlaveClient:
    def __init__(self, settings: dict, logger: logging.Logger):
        self.settings = settings
        self.logger = logger
        self.ws = None
        self.session_token = None
        self.running = False
        self.engine = None

        # Task handlers
        self.handlers = {
            MessageType.WELCOME: self._handle_welcome,
            MessageType.CONFIG_PUSH: self._handle_config,
            MessageType.TASK_ASSIGN: self._handle_task,
            MessageType.SCAN_REQUEST: self._handle_scan,
        }

    async def run(self):
        """Main loop with auto-reconnect."""
        self.running = True
        while self.running:
            try:
                await self._connect()
                await self._message_loop()
            except ConnectionClosed:
                self.logger.warning("Connection lost, reconnecting...")
                await asyncio.sleep(self.settings.get("reconnect_delay", 5))
            except Exception as e:
                self.logger.error(f"Error: {e}")
                await asyncio.sleep(5)

    async def _connect(self):
        """Establish authenticated connection to master."""
        uri = f"ws://{self.settings['master_host']}:{self.settings['master_port']}"
        self.ws = await websockets.connect(uri)

        # Send HELLO with auth
        await self._send(Message(
            type=MessageType.HELLO,
            payload={
                "name": self.settings["slave_name"],
                "capabilities": ["traffic", "proxy_scrape", "scan"],
                "auth_hash": self._compute_auth_hash(),
            },
            node_id=self.settings["slave_name"],
        ))

    async def _handle_task(self, msg: Message):
        """Execute traffic generation task."""
        config = TrafficConfig(**msg.payload["config"])
        proxies = [ProxyConfig(**p) for p in msg.payload["proxies"]]

        self.engine = AsyncTrafficEngine(
            config=config,
            proxies=proxies,
            on_update=lambda stats: self._send_stats(stats),
            on_log=lambda m: self.logger.info(m),
        )

        await self.engine.run()

        await self._send(Message(
            type=MessageType.TASK_COMPLETE,
            payload={"task_id": msg.payload["task_id"]},
        ))
```

### Phase 3: Master Components

**Duration:** 2-3 sessions

**New UI Page:**
```
ui/pages/
└── master_control.py    # Master/Slave management page
```

**Page Layout:**
```
┌─────────────────────────────────────────────────────────────────┐
│  MASTER CONTROL                                     [⚙ Config]  │
├─────────────────────────────────────────────────────────────────┤
│  Server Status: ● RUNNING on 0.0.0.0:8765          [Stop Server]│
├─────────────────────────────────────────────────────────────────┤
│  CONNECTED SLAVES (3)                              [Refresh]    │
│ ┌─────────────────────────────────────────────────────────────┐ │
│ │ Name        │ IP Address    │ Status │ Tasks │ Last Seen   │ │
│ ├─────────────────────────────────────────────────────────────┤ │
│ │ slave-01    │ 192.168.1.101 │ ● Idle │   0   │ 2s ago      │ │
│ │ slave-02    │ 192.168.1.102 │ ● Busy │   3   │ 1s ago      │ │
│ │ slave-03    │ 10.0.0.50     │ ● Idle │   0   │ 5s ago      │ │
│ └─────────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────────┤
│  TASK DISTRIBUTION                                              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────┐  │
│  │ Target URL:  │  │ Total Tasks: │  │ Distribution:        │  │
│  │ [__________] │  │ [___100___]  │  │ (●) Round-robin      │  │
│  └──────────────┘  └──────────────┘  │ ( ) Weighted         │  │
│                                       │ ( ) Random           │  │
│  [Distribute Tasks]  [Stop All]       └──────────────────────┘  │
├─────────────────────────────────────────────────────────────────┤
│  AGGREGATED STATS                                               │
│  ┌────────────┐ ┌────────────┐ ┌────────────┐ ┌────────────┐   │
│  │ Total Req  │ │ Success    │ │ Failed     │ │ Active     │   │
│  │   45,231   │ │   44,892   │ │     339    │ │     150    │   │
│  └────────────┘ └────────────┘ └────────────┘ └────────────┘   │
├─────────────────────────────────────────────────────────────────┤
│  ACTIVITY LOG                                                   │
│ ┌─────────────────────────────────────────────────────────────┐ │
│ │ [12:34:56] slave-02 connected from 192.168.1.102            │ │
│ │ [12:34:58] Distributed 50 tasks to slave-01                 │ │
│ │ [12:35:01] slave-01 completed batch (98% success)           │ │
│ └─────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
```

**SlaveManager Class:**
```python
# core/network/server.py
class SlaveManager:
    def __init__(self, settings: dict, on_log: Callable):
        self.settings = settings
        self.on_log = on_log
        self.slaves: dict[str, SlaveConnection] = {}
        self.server = None
        self.aggregated_stats = AggregatedStats()

    async def start(self, host: str = "0.0.0.0", port: int = 8765):
        """Start WebSocket server."""
        self.server = await websockets.serve(
            self._handle_connection,
            host,
            port,
        )
        self.on_log(f"Master server started on {host}:{port}")

    async def _handle_connection(self, websocket):
        """Handle incoming slave connection."""
        try:
            # Wait for HELLO
            msg = await self._receive(websocket)
            if msg.type != MessageType.HELLO:
                await websocket.close(1002, "Expected HELLO")
                return

            # Verify authentication
            if not self._verify_auth(msg.payload):
                await websocket.close(1008, "Authentication failed")
                return

            # Register slave
            slave = SlaveConnection(
                node_id=msg.node_id,
                websocket=websocket,
                capabilities=msg.payload.get("capabilities", []),
            )
            self.slaves[msg.node_id] = slave
            self.on_log(f"Slave '{msg.node_id}' connected")

            # Send WELCOME with config
            await self._send(websocket, Message(
                type=MessageType.WELCOME,
                payload={"config": self._get_slave_config()},
            ))

            # Handle messages until disconnect
            await self._slave_loop(slave)

        except ConnectionClosed:
            pass
        finally:
            if msg and msg.node_id in self.slaves:
                del self.slaves[msg.node_id]
                self.on_log(f"Slave '{msg.node_id}' disconnected")

    def distribute_tasks(self, config: TrafficConfig, total_tasks: int):
        """Distribute traffic tasks across connected slaves."""
        if not self.slaves:
            self.on_log("No slaves connected")
            return

        tasks_per_slave = total_tasks // len(self.slaves)
        remainder = total_tasks % len(self.slaves)

        for i, (node_id, slave) in enumerate(self.slaves.items()):
            count = tasks_per_slave + (1 if i < remainder else 0)
            asyncio.create_task(self._assign_task(slave, config, count))
```

### Phase 4: SSH/RDP Scanner Module

**Duration:** 2-3 sessions

**SECURITY FIRST:** This module requires explicit authorization controls.

**New Files:**
```
core/
├── scanner/
│   ├── __init__.py
│   ├── base.py              # Scanner base class
│   ├── port_scanner.py      # TCP port scanning
│   ├── ssh_scanner.py       # SSH detection & credential testing
│   ├── rdp_scanner.py       # RDP detection & credential testing
│   └── models.py            # ScanTarget, ScanResult, Credential
```

**Scanner Base Class:**
```python
# core/scanner/base.py
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
from typing import Optional, List
import asyncio

class ScanStatus(Enum):
    OPEN = "open"
    CLOSED = "closed"
    FILTERED = "filtered"
    AUTH_SUCCESS = "auth_success"
    AUTH_FAILED = "auth_failed"

@dataclass
class ScanResult:
    host: str
    port: int
    status: ScanStatus
    service: Optional[str] = None
    banner: Optional[str] = None
    credentials: Optional[tuple[str, str]] = None  # (user, pass) if found
    latency_ms: float = 0.0

class BaseScanner(ABC):
    def __init__(
        self,
        timeout: float = 5.0,
        max_concurrent: int = 100,
        rate_limit: float = 0.0,  # Seconds between attempts
        on_result: Optional[Callable[[ScanResult], None]] = None,
        on_log: Optional[Callable[[str], None]] = None,
    ):
        self.timeout = timeout
        self.max_concurrent = max_concurrent
        self.rate_limit = rate_limit
        self.on_result = on_result
        self.on_log = on_log or print
        self._stop_event = asyncio.Event()
        self._semaphore = asyncio.Semaphore(max_concurrent)

    @abstractmethod
    async def scan_host(self, host: str, port: int) -> ScanResult:
        """Scan a single host:port."""
        pass

    async def scan_range(
        self,
        hosts: List[str],
        ports: List[int],
    ) -> List[ScanResult]:
        """Scan multiple hosts and ports."""
        tasks = []
        for host in hosts:
            for port in ports:
                if self._stop_event.is_set():
                    break
                tasks.append(self._rate_limited_scan(host, port))

        return await asyncio.gather(*tasks, return_exceptions=True)

    async def _rate_limited_scan(self, host: str, port: int) -> ScanResult:
        async with self._semaphore:
            if self.rate_limit > 0:
                await asyncio.sleep(self.rate_limit)
            result = await self.scan_host(host, port)
            if self.on_result:
                self.on_result(result)
            return result

    def stop(self):
        self._stop_event.set()
```

**SSH Scanner:**
```python
# core/scanner/ssh_scanner.py
import asyncio
import asyncssh  # Add to requirements.txt

class SSHScanner(BaseScanner):
    def __init__(
        self,
        credentials: List[tuple[str, str]] = None,  # (user, pass) pairs
        test_credentials: bool = False,
        **kwargs,
    ):
        super().__init__(**kwargs)
        self.credentials = credentials or []
        self.test_credentials = test_credentials

    async def scan_host(self, host: str, port: int = 22) -> ScanResult:
        """Scan SSH service on host."""
        start = asyncio.get_event_loop().time()

        try:
            # Port check first
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port),
                timeout=self.timeout,
            )

            # Read banner
            banner = await asyncio.wait_for(
                reader.readline(),
                timeout=2.0,
            )
            banner = banner.decode("utf-8", errors="ignore").strip()

            writer.close()
            await writer.wait_closed()

            latency = (asyncio.get_event_loop().time() - start) * 1000

            result = ScanResult(
                host=host,
                port=port,
                status=ScanStatus.OPEN,
                service="ssh",
                banner=banner,
                latency_ms=latency,
            )

            # Optional credential testing
            if self.test_credentials and self.credentials:
                cred_result = await self._test_credentials(host, port)
                if cred_result:
                    result.status = ScanStatus.AUTH_SUCCESS
                    result.credentials = cred_result

            return result

        except asyncio.TimeoutError:
            return ScanResult(host=host, port=port, status=ScanStatus.FILTERED)
        except ConnectionRefusedError:
            return ScanResult(host=host, port=port, status=ScanStatus.CLOSED)
        except Exception as e:
            self.on_log(f"SSH scan error {host}:{port}: {e}")
            return ScanResult(host=host, port=port, status=ScanStatus.FILTERED)

    async def _test_credentials(
        self,
        host: str,
        port: int,
    ) -> Optional[tuple[str, str]]:
        """Test credential pairs against SSH server."""
        for username, password in self.credentials:
            if self._stop_event.is_set():
                break

            try:
                async with asyncssh.connect(
                    host,
                    port=port,
                    username=username,
                    password=password,
                    known_hosts=None,
                    connect_timeout=self.timeout,
                ) as conn:
                    # Connection successful
                    self.on_log(f"SSH auth success: {username}@{host}:{port}")
                    return (username, password)
            except asyncssh.PermissionDenied:
                continue  # Wrong credentials
            except Exception:
                continue  # Other error, try next

            if self.rate_limit > 0:
                await asyncio.sleep(self.rate_limit)

        return None
```

**RDP Scanner (Smart TPKT/X.224 Detection):**
```python
# core/scanner/rdp_scanner.py
import asyncio
import struct

class RDPScanner(BaseScanner):
    """
    Smart RDP detection using TPKT/X.224 Connection Request.
    Sends minimal 19-byte packet, confirms RDP via valid negotiation response.
    No heavy RDP libraries required.
    """

    # TPKT Header (4 bytes) + X.224 Connection Request (15 bytes minimum)
    # This is the minimal packet to trigger an RDP negotiation response
    RDP_NEG_REQ = bytes([
        # TPKT Header
        0x03,  # Version
        0x00,  # Reserved
        0x00, 0x13,  # Length (19 bytes total)

        # X.224 Connection Request
        0x0e,  # Length indicator
        0xe0,  # Connection Request (CR) TPDU
        0x00, 0x00,  # DST-REF
        0x00, 0x00,  # SRC-REF
        0x00,  # Class 0

        # RDP Negotiation Request
        0x01,  # TYPE_RDP_NEG_REQ
        0x00,  # Flags
        0x08, 0x00,  # Length (8 bytes)
        0x03, 0x00, 0x00, 0x00,  # requestedProtocols: TLS + CredSSP
    ])

    async def scan_host(self, host: str, port: int = 3389) -> ScanResult:
        """Detect RDP service via protocol handshake."""
        start = asyncio.get_event_loop().time()

        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port),
                timeout=self.timeout,
            )

            # Send RDP negotiation request
            writer.write(self.RDP_NEG_REQ)
            await writer.drain()

            # Read response (expect TPKT + X.224 + RDP_NEG_RSP)
            response = await asyncio.wait_for(
                reader.read(64),
                timeout=3.0,
            )

            writer.close()
            await writer.wait_closed()

            latency = (asyncio.get_event_loop().time() - start) * 1000

            # Validate response
            if self._is_valid_rdp_response(response):
                rdp_info = self._parse_rdp_response(response)
                return ScanResult(
                    host=host,
                    port=port,
                    status=ScanStatus.OPEN,
                    service="rdp",
                    banner=rdp_info.get("protocol", "RDP"),
                    latency_ms=latency,
                )
            else:
                # Port open but not RDP (or filtered response)
                return ScanResult(
                    host=host,
                    port=port,
                    status=ScanStatus.OPEN,
                    service="unknown",
                    banner="Non-RDP service on 3389",
                    latency_ms=latency,
                )

        except asyncio.TimeoutError:
            return ScanResult(host=host, port=port, status=ScanStatus.FILTERED)
        except ConnectionRefusedError:
            return ScanResult(host=host, port=port, status=ScanStatus.CLOSED)
        except Exception as e:
            self.on_log(f"RDP scan error {host}:{port}: {e}")
            return ScanResult(host=host, port=port, status=ScanStatus.FILTERED)

    def _is_valid_rdp_response(self, data: bytes) -> bool:
        """Check if response is valid TPKT + X.224 + RDP negotiation."""
        if len(data) < 11:
            return False

        # Check TPKT header
        if data[0] != 0x03:  # TPKT version
            return False

        # Check X.224 Connection Confirm (0xd0) or RDP_NEG_RSP/FAILURE
        x224_type = data[5]
        if x224_type not in (0xd0, 0xd1):  # CC or failure
            return False

        return True

    def _parse_rdp_response(self, data: bytes) -> dict:
        """Extract protocol info from RDP negotiation response."""
        result = {"protocol": "RDP"}

        if len(data) < 19:
            return result

        # Parse RDP_NEG_RSP if present (starts at byte 11)
        try:
            neg_type = data[11]  # 0x02 = RSP, 0x03 = FAILURE

            if neg_type == 0x02:  # TYPE_RDP_NEG_RSP
                # selectedProtocol at bytes 15-18
                selected = struct.unpack('<I', data[15:19])[0]

                protocols = []
                if selected == 0:
                    protocols.append("Standard RDP")
                if selected & 0x01:
                    protocols.append("TLS")
                if selected & 0x02:
                    protocols.append("CredSSP/NLA")
                if selected & 0x08:
                    protocols.append("RDSTLS")

                result["protocol"] = "RDP (" + ", ".join(protocols) + ")"
                result["selected_protocol"] = selected

            elif neg_type == 0x03:  # TYPE_RDP_NEG_FAILURE
                result["protocol"] = "RDP (Negotiation Failed)"

        except (IndexError, struct.error):
            pass

        return result
```

**RDP Scanner Output Examples:**
```
# TLS-enabled RDP server
ScanResult(host="10.0.0.5", port=3389, status=OPEN, service="rdp",
           banner="RDP (TLS, CredSSP/NLA)")

# Legacy RDP (no TLS/NLA)
ScanResult(host="10.0.0.6", port=3389, status=OPEN, service="rdp",
           banner="RDP (Standard RDP)")

# Something else on port 3389
ScanResult(host="10.0.0.7", port=3389, status=OPEN, service="unknown",
           banner="Non-RDP service on 3389")
```

**Authorization Dialog (Master GUI):**
```python
# In ui/pages/master_control.py - Scanner section
def _show_scan_authorization(self):
    """Show authorization dialog before scanning."""
    dialog = ctk.CTkToplevel(self.app)
    dialog.title("⚠️ Security Scanner Authorization")
    dialog.geometry("500x400")
    dialog.transient(self.app)
    dialog.grab_set()

    # Warning text
    warning = ctk.CTkLabel(
        dialog,
        text="⚠️ AUTHORIZED TESTING ONLY ⚠️",
        font=("Arial", 16, "bold"),
        text_color="#ff6b6b",
    )
    warning.pack(pady=20)

    disclaimer = ctk.CTkTextbox(dialog, height=200)
    disclaimer.insert("1.0", """
LEGAL DISCLAIMER

This scanner is intended ONLY for:
• Systems you own
• Systems you have explicit written permission to test
• Authorized penetration testing engagements
• CTF competitions and security research

Unauthorized scanning or credential testing is ILLEGAL
and may violate computer crime laws including:
• Computer Fraud and Abuse Act (US)
• Computer Misuse Act (UK)
• Similar laws in your jurisdiction

By proceeding, you confirm that you have proper
authorization to scan the specified targets.
    """)
    disclaimer.configure(state="disabled")
    disclaimer.pack(padx=20, fill="x")

    # Checkbox for acceptance
    self.scan_authorized = ctk.BooleanVar(value=False)
    checkbox = ctk.CTkCheckBox(
        dialog,
        text="I confirm I have authorization to scan these targets",
        variable=self.scan_authorized,
    )
    checkbox.pack(pady=20)

    # Buttons
    btn_frame = ctk.CTkFrame(dialog, fg_color="transparent")
    btn_frame.pack(pady=10)

    ctk.CTkButton(
        btn_frame,
        text="Cancel",
        command=dialog.destroy,
        fg_color="#666",
    ).pack(side="left", padx=10)

    ctk.CTkButton(
        btn_frame,
        text="Proceed with Scan",
        command=lambda: self._start_scan(dialog),
        fg_color="#6e179b",
    ).pack(side="left", padx=10)
```

### Phase 5: Linux Deployment System

**Duration:** 1-2 sessions

**Target:** Debian 11+/Ubuntu 22.04+ servers (cheap VPS, $3-5/month)

#### 5.1 Slave Requirements (Minimal)

The slave does NOT need GUI libraries. Create a minimal requirements file:

```
# requirements-slave.txt (Linux headless only)
# No customtkinter, no playwright (unless browser engine needed)

# Core networking
websockets>=12.0
curl_cffi>=0.7.0
aiohttp>=3.9.0

# Authentication
cryptography>=41.0.0

# Scanner (optional)
asyncssh>=2.14.0

# Utilities
fake-useragent>=1.4.0
```

**Disk footprint:** ~50MB (vs ~500MB+ with GUI libs)

#### 5.2 systemd Service File

```ini
# /etc/systemd/system/dm-slave.service
[Unit]
Description=DarkMatter Traffic Bot Slave
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
User=dm-slave
Group=dm-slave
WorkingDirectory=/opt/dm-slave
Environment="PATH=/opt/dm-slave/venv/bin"
EnvironmentFile=/etc/dm-slave/config
ExecStart=/opt/dm-slave/venv/bin/python slave.py
Restart=always
RestartSec=10

# Security hardening
NoNewPrivileges=yes
ProtectSystem=strict
ProtectHome=yes
PrivateTmp=yes
ReadWritePaths=/opt/dm-slave

# Resource limits (adjust per VPS)
MemoryMax=512M
CPUQuota=80%

[Install]
WantedBy=multi-user.target
```

#### 5.3 Environment Configuration

```bash
# /etc/dm-slave/config
DM_MASTER_HOST=master.example.com
DM_MASTER_PORT=8765
DM_SLAVE_SECRET=your-secret-key-here
DM_SLAVE_NAME=slave-us-east-01
DM_LOG_LEVEL=INFO
```

**Permissions:**
```bash
sudo chmod 600 /etc/dm-slave/config
sudo chown dm-slave:dm-slave /etc/dm-slave/config
```

#### 5.4 Installation Script

```bash
#!/bin/bash
# deploy/install-slave.sh
# Run as root: curl -sSL https://raw.githubusercontent.com/.../install-slave.sh | sudo bash

set -euo pipefail

INSTALL_DIR="/opt/dm-slave"
CONFIG_DIR="/etc/dm-slave"
REPO_URL="https://github.com/SneezeGUI/DM-TrafficBot.git"
BRANCH="main"

echo "=== DarkMatter Slave Installer ==="
echo "Target: Debian/Ubuntu Linux"
echo ""

# Check if running as root
if [ "$EUID" -ne 0 ]; then
    echo "ERROR: Run as root (sudo)"
    exit 1
fi

# Detect distro
if [ -f /etc/debian_version ]; then
    echo "[✓] Debian/Ubuntu detected"
else
    echo "[!] Warning: Untested distro. Continuing anyway..."
fi

# Install system dependencies
echo "[*] Installing system packages..."
apt-get update -qq
apt-get install -y -qq python3 python3-venv python3-pip git curl

# Create service user
echo "[*] Creating dm-slave user..."
if ! id "dm-slave" &>/dev/null; then
    useradd --system --no-create-home --shell /usr/sbin/nologin dm-slave
fi

# Create directories
echo "[*] Creating directories..."
mkdir -p "$INSTALL_DIR"
mkdir -p "$CONFIG_DIR"

# Clone or update repo
if [ -d "$INSTALL_DIR/.git" ]; then
    echo "[*] Updating existing installation..."
    cd "$INSTALL_DIR"
    git fetch origin
    git reset --hard "origin/$BRANCH"
else
    echo "[*] Cloning repository..."
    git clone --branch "$BRANCH" --depth 1 "$REPO_URL" "$INSTALL_DIR"
fi

# Create virtual environment
echo "[*] Setting up Python virtual environment..."
cd "$INSTALL_DIR"
python3 -m venv venv
source venv/bin/activate

# Install minimal dependencies (no GUI)
echo "[*] Installing Python dependencies..."
pip install --quiet --upgrade pip
pip install --quiet -r requirements-slave.txt

# Create default config if not exists
if [ ! -f "$CONFIG_DIR/config" ]; then
    echo "[*] Creating default config..."
    cat > "$CONFIG_DIR/config" << 'EOF'
# DarkMatter Slave Configuration
# Edit these values before starting the service

DM_MASTER_HOST=127.0.0.1
DM_MASTER_PORT=8765
DM_SLAVE_SECRET=CHANGE_ME
DM_SLAVE_NAME=slave-01
DM_LOG_LEVEL=INFO
EOF
    chmod 600 "$CONFIG_DIR/config"
fi

# Install systemd service
echo "[*] Installing systemd service..."
cat > /etc/systemd/system/dm-slave.service << 'EOF'
[Unit]
Description=DarkMatter Traffic Bot Slave
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
User=dm-slave
Group=dm-slave
WorkingDirectory=/opt/dm-slave
Environment="PATH=/opt/dm-slave/venv/bin"
EnvironmentFile=/etc/dm-slave/config
ExecStart=/opt/dm-slave/venv/bin/python slave.py
Restart=always
RestartSec=10
NoNewPrivileges=yes
ProtectSystem=strict
ProtectHome=yes
PrivateTmp=yes
ReadWritePaths=/opt/dm-slave
MemoryMax=512M
CPUQuota=80%

[Install]
WantedBy=multi-user.target
EOF

# Set ownership
chown -R dm-slave:dm-slave "$INSTALL_DIR"
chown -R dm-slave:dm-slave "$CONFIG_DIR"

# Reload systemd
systemctl daemon-reload

echo ""
echo "=== Installation Complete ==="
echo ""
echo "Next steps:"
echo "  1. Edit config:     sudo nano /etc/dm-slave/config"
echo "  2. Start service:   sudo systemctl start dm-slave"
echo "  3. Enable on boot:  sudo systemctl enable dm-slave"
echo "  4. View logs:       journalctl -u dm-slave -f"
echo ""
```

#### 5.5 Slave Management Commands

```bash
# Start/Stop/Restart
sudo systemctl start dm-slave
sudo systemctl stop dm-slave
sudo systemctl restart dm-slave

# View status
sudo systemctl status dm-slave

# View logs (live)
journalctl -u dm-slave -f

# View logs (last 100 lines)
journalctl -u dm-slave -n 100

# View logs (since boot)
journalctl -u dm-slave -b

# View logs (last hour)
journalctl -u dm-slave --since "1 hour ago"

# Enable/Disable auto-start
sudo systemctl enable dm-slave
sudo systemctl disable dm-slave

# Update slave
cd /opt/dm-slave && sudo git pull && sudo systemctl restart dm-slave
```

#### 5.6 Multi-Slave Deployment (Ansible)

For deploying to multiple servers:

```yaml
# deploy/ansible/playbook.yml
---
- name: Deploy DarkMatter Slave
  hosts: slaves
  become: yes
  vars:
    master_host: "{{ lookup('env', 'DM_MASTER_HOST') }}"
    slave_secret: "{{ lookup('env', 'DM_SLAVE_SECRET') }}"

  tasks:
    - name: Run install script
      script: ../install-slave.sh

    - name: Configure slave
      template:
        src: templates/config.j2
        dest: /etc/dm-slave/config
        mode: '0600'
        owner: dm-slave
        group: dm-slave
      notify: Restart dm-slave

    - name: Start and enable service
      systemd:
        name: dm-slave
        state: started
        enabled: yes

  handlers:
    - name: Restart dm-slave
      systemd:
        name: dm-slave
        state: restarted
```

```ini
# deploy/ansible/inventory.ini
[slaves]
slave-us-east-01 ansible_host=192.168.1.101 slave_name=slave-us-east-01
slave-us-west-01 ansible_host=192.168.1.102 slave_name=slave-us-west-01
slave-eu-west-01 ansible_host=192.168.1.103 slave_name=slave-eu-west-01
```

```bash
# Deploy to all slaves
ansible-playbook -i inventory.ini playbook.yml
```

#### 5.7 Recommended VPS Providers

| Provider | Plan | RAM | Cost/mo | Notes |
|----------|------|-----|---------|-------|
| Vultr | Cloud Compute | 1GB | $5 | Good global coverage |
| DigitalOcean | Basic Droplet | 1GB | $6 | Reliable, good docs |
| Hetzner | CX11 | 2GB | €3.29 | Best EU value |
| OVH | VPS Starter | 2GB | $3.50 | Cheap, decent |
| Contabo | VPS S | 8GB | €4.99 | Most RAM/$ |

**Minimum specs:** 1 vCPU, 512MB RAM, 10GB disk, Debian 11+

#### 5.8 Zero-Touch Management (Configure Once, Manage from Master)

**Design Goal:** After initial 3-value configuration, slaves run autonomously and accept all config updates from the master GUI. No SSH required for day-to-day management.

**Initial Setup (One-Time Only):**
```bash
# Only 3 values needed to bootstrap:
DM_MASTER_HOST=master.example.com
DM_MASTER_PORT=8765
DM_SLAVE_SECRET=shared-secret-key
```

After this, the slave:
1. Connects to master on boot (systemd)
2. Authenticates with shared secret
3. Receives full configuration from master
4. Stores config locally for offline resilience
5. Accepts live config updates without restart

**Remote Configuration Protocol:**

```python
# core/network/protocol.py - Config sync messages

class MessageType(Enum):
    # ... existing messages ...

    # Remote configuration (Master -> Slave)
    CONFIG_PUSH = "config_push"      # Full config replacement
    CONFIG_PATCH = "config_patch"    # Partial update (delta)
    CONFIG_ACK = "config_ack"        # Slave confirms applied

    # Remote management
    SLAVE_RESTART = "slave_restart"  # Trigger graceful restart
    SLAVE_UPDATE = "slave_update"    # Pull latest code from git
    SLAVE_STATUS = "slave_status"    # Request system stats
```

**Slave Config Storage:**
```python
# On slave: /opt/dm-slave/runtime_config.json
# Updated whenever master pushes config
# Used as fallback if master unreachable on boot

{
    "last_updated": "2025-12-22T14:30:00Z",
    "pushed_by": "master",
    "config": {
        "traffic_threads": 50,
        "proxy_timeout": 5000,
        "burst_mode": true,
        "burst_requests": 10,
        "capabilities": ["traffic", "proxy_scrape", "scan"],
        "rate_limits": {
            "scan_rps": 100,
            "traffic_rps": 0
        }
    }
}
```

**SlaveClient Remote Config Handler:**
```python
# core/network/client.py

class SlaveClient:
    def __init__(self, settings: dict, logger: logging.Logger):
        # ... existing init ...
        self.runtime_config_path = Path("/opt/dm-slave/runtime_config.json")
        self.runtime_config = self._load_runtime_config()

    def _load_runtime_config(self) -> dict:
        """Load cached config from disk (fallback if master offline)."""
        if self.runtime_config_path.exists():
            with open(self.runtime_config_path) as f:
                data = json.load(f)
                self.logger.info(f"Loaded cached config from {data.get('last_updated')}")
                return data.get("config", {})
        return {}

    def _save_runtime_config(self, config: dict):
        """Persist config to disk for offline resilience."""
        data = {
            "last_updated": datetime.utcnow().isoformat() + "Z",
            "pushed_by": "master",
            "config": config,
        }
        with open(self.runtime_config_path, "w") as f:
            json.dump(data, f, indent=2)
        self.logger.info("Runtime config saved to disk")

    async def _handle_config_push(self, msg: Message):
        """Handle full config replacement from master."""
        new_config = msg.payload.get("config", {})

        # Merge with existing (master config takes precedence)
        self.runtime_config.update(new_config)

        # Persist to disk
        self._save_runtime_config(self.runtime_config)

        # Apply config changes (thread count, rate limits, etc.)
        self._apply_config(self.runtime_config)

        # Acknowledge
        await self._send(Message(
            type=MessageType.CONFIG_ACK,
            payload={"status": "applied", "config_hash": self._config_hash()},
        ))

        self.logger.info(f"Config pushed from master: {len(new_config)} settings updated")

    async def _handle_config_patch(self, msg: Message):
        """Handle partial config update (delta)."""
        patch = msg.payload.get("patch", {})

        for key, value in patch.items():
            if value is None:
                self.runtime_config.pop(key, None)  # Delete
            else:
                self.runtime_config[key] = value    # Update

        self._save_runtime_config(self.runtime_config)
        self._apply_config(self.runtime_config)

        await self._send(Message(
            type=MessageType.CONFIG_ACK,
            payload={"status": "patched", "keys": list(patch.keys())},
        ))
```

**Master GUI: Remote Config Panel**
```
┌─────────────────────────────────────────────────────────────────┐
│  SLAVE CONFIGURATION: slave-us-east-01                          │
├─────────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐  │
│  │ Traffic Threads │  │ Proxy Timeout   │  │ Burst Mode      │  │
│  │ [____50____]    │  │ [___5000___] ms │  │ [✓] Enabled     │  │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘  │
│                                                                  │
│  Capabilities:                                                   │
│  [✓] Traffic Generation   [✓] Proxy Scraping   [✓] Scanning    │
│                                                                  │
│  Rate Limits:                                                    │
│  ┌─────────────────┐  ┌─────────────────┐                       │
│  │ Scan RPS:       │  │ Traffic RPS:    │                       │
│  │ [____100____]   │  │ [____0____] (0=unlimited)               │
│  └─────────────────┘  └─────────────────┘                       │
│                                                                  │
│  [Push Config]  [Push to ALL Slaves]  [Reset to Defaults]       │
├─────────────────────────────────────────────────────────────────┤
│  Remote Actions:                                                 │
│  [Restart Slave]  [Update Code (git pull)]  [View Logs]         │
└─────────────────────────────────────────────────────────────────┘
```

**Offline Resilience:**
```
Scenario: Master goes offline, slave reboots

1. Slave starts (systemd)
2. Loads runtime_config.json from disk
3. Attempts to connect to master (fails)
4. Continues with cached config
5. Retries connection every 30s (configurable)
6. When master returns, syncs config delta
```

**Security Considerations:**
- Config changes require valid session token (authenticated connection)
- Sensitive settings (secret key, master host) CANNOT be changed remotely
- All config pushes logged to journalctl
- Optional: Config change webhook to external logging

---

### Phase 6: Integration & Testing

**Duration:** 2 sessions

**Integration Tests:**
```python
# tests/test_network.py
import pytest
import asyncio
from core.network.server import SlaveManager
from core.network.client import SlaveClient
from core.network.protocol import Message, MessageType

@pytest.fixture
async def master_server():
    manager = SlaveManager({"slave_secret_key": "test123"}, print)
    await manager.start("127.0.0.1", 0)  # Random port
    port = manager.server.sockets[0].getsockname()[1]
    yield manager, port
    manager.server.close()
    await manager.server.wait_closed()

@pytest.fixture
async def slave_client(master_server):
    manager, port = master_server
    settings = {
        "master_host": "127.0.0.1",
        "master_port": port,
        "slave_secret_key": "test123",
        "slave_name": "test-slave",
    }
    client = SlaveClient(settings, logging.getLogger())
    yield client
    await client.cleanup()

@pytest.mark.asyncio
async def test_slave_connection(master_server, slave_client):
    """Test slave can connect and authenticate."""
    manager, port = master_server

    # Connect in background
    connect_task = asyncio.create_task(slave_client._connect())

    # Wait for connection
    await asyncio.sleep(0.5)

    assert "test-slave" in manager.slaves
    assert manager.slaves["test-slave"].websocket.open

@pytest.mark.asyncio
async def test_task_distribution(master_server, slave_client):
    """Test master can distribute tasks to slave."""
    # ... test implementation
```

---

## Part 4: Dependency Changes

### New Requirements (requirements.txt additions)

```
# Networking (v3.7.0)
websockets>=12.0

# Cryptography (v3.7.0)
cryptography>=41.0.0

# SSH Scanner (v3.7.0)
asyncssh>=2.14.0

# RDP Scanner (v3.7.0)
# Smart detection via TPKT/X.224 handshake (no heavy libs needed)
```

### Dev Requirements Additions

```
# Testing async code
pytest-asyncio>=0.23.0

# Mocking WebSockets
pytest-mock>=3.12.0
```

---

## Part 5: Recommended Implementation Order

### Pre-v3.7.0 Release (v3.6.5)

| Task | Priority | Sessions | Blocks |
|------|----------|----------|--------|
| 1. Testing infrastructure | CRITICAL | 2-3 | Everything |
| 2. Config env vars | HIGH | 1 | Secrets handling |
| 3. Proxy chaining | MEDIUM | 1-2 | None |

**Total: 4-6 sessions**

*Note: File-based logging removed - systemd journalctl handles this automatically on Linux slaves.*

### v3.7.0 Phases

| Phase | Description | Sessions | Dependencies |
|-------|-------------|----------|--------------|
| 1 | Communication Layer | 2-3 | Pre-v3.7.0 complete |
| 2 | Headless Client (slave.py) | 2 | Phase 1 |
| 3 | Master Components | 2-3 | Phase 1, 2 |
| 4 | SSH/RDP Scanner | 2-3 | Phase 2 |
| 5 | Linux Deployment (systemd, scripts) | 1-2 | Phase 2 |
| 6 | Integration Testing | 2 | All phases |
| 7 | Documentation | 1 | All phases |

**Total: 13-18 sessions**

---

## Part 6: Risk Mitigation

### Technical Risks

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| WebSocket reliability | Medium | High | Heartbeat + auto-reconnect (systemd restarts) |
| Auth bypass | Low | Critical | Rate limiting, HMAC verification |
| Scanner abuse | Medium | Critical | Auth dialog, logging, rate limits |
| Memory leaks (long-running) | Medium | Medium | systemd MemoryMax, periodic restarts |
| Slave connectivity | Medium | Medium | Auto-reconnect, journalctl monitoring |

### Security Risks

| Risk | Mitigation |
|------|------------|
| Secret key exposure | Env vars, not file storage |
| Man-in-the-middle | TLS for production (wss://) |
| Credential logging | Never log passwords, hash comparisons |
| Scanner misuse | Legal disclaimer, authorization check |

---

## Appendix: File Structure After v3.7.0

```
web-traffic-tool/
├── main.py                     # GUI entry point (Windows master)
├── slave.py                    # NEW: Headless slave entry point (Linux)
├── requirements.txt            # Full deps (master with GUI)
├── requirements-slave.txt      # NEW: Minimal deps (Linux slave, no GUI)
├── core/
│   ├── __init__.py
│   ├── logging_config.py       # NEW: Simple stdout logging (systemd captures)
│   ├── engine.py
│   ├── browser_engine.py
│   ├── stress_engine.py
│   ├── proxy_manager.py
│   ├── models.py               # MODIFIED: Add slave/network models
│   ├── network/                # NEW: Network layer
│   │   ├── __init__.py
│   │   ├── protocol.py         # Message definitions
│   │   ├── server.py           # Master WebSocket server
│   │   ├── client.py           # Slave WebSocket client
│   │   └── auth.py             # Authentication
│   └── scanner/                # NEW: Security scanners
│       ├── __init__.py
│       ├── base.py             # Scanner base class
│       ├── port_scanner.py     # Port scanning
│       ├── ssh_scanner.py      # SSH scanner
│       ├── rdp_scanner.py      # RDP scanner
│       └── models.py           # Scanner data models
├── ui/
│   ├── app.py                  # MODIFIED: Add master mode
│   └── pages/
│       ├── master_control.py   # NEW: Master/Slave management
│       └── ...
├── deploy/                     # NEW: Linux deployment
│   ├── install-slave.sh        # One-liner install script
│   ├── dm-slave.service        # systemd service file
│   ├── config.example          # Example environment config
│   └── ansible/                # Multi-server deployment
│       ├── playbook.yml
│       ├── inventory.ini
│       └── templates/
│           └── config.j2
├── tests/                      # NEW: Test directory
│   ├── __init__.py
│   ├── conftest.py
│   ├── test_models.py
│   ├── test_validators.py
│   ├── test_utils.py
│   ├── test_network.py
│   └── test_scanner.py
└── docs/
    └── v3.7.0-plan.md          # This document
```

### Linux Slave Directory Structure (on server)

```
/opt/dm-slave/                  # Application directory
├── venv/                       # Python virtual environment
├── slave.py                    # Entry point
├── core/                       # Core modules
└── requirements-slave.txt

/etc/dm-slave/                  # Configuration
└── config                      # Environment variables (chmod 600)

# Logs via journalctl (no files needed)
journalctl -u dm-slave -f
```

---

## Summary

**v3.7.0 is ambitious but achievable** with proper foundational work.

**Architecture:**
- **Master:** Windows GUI (existing app + new Master Control page)
- **Slave:** Headless Linux (Debian/Ubuntu, systemd-managed, ~50MB footprint)
- **Communication:** WebSocket with HMAC authentication
- **Management:** Zero-touch after initial 3-value config (master_host, port, secret)

**Critical Path:**
1. ✅ Complete v3.6.1 refactor (DONE)
2. 🔲 Add testing infrastructure (CRITICAL)
3. 🔲 Enhance configuration system (env vars)
4. 🔲 Implement communication layer (WebSocket)
5. 🔲 Build headless client (slave.py)
6. 🔲 Add master GUI page
7. 🔲 Implement scanners (SSH/RDP)
8. 🔲 Linux deployment (systemd, install script)
9. 🔲 Integration testing
10. 🔲 Documentation & release

**Deployment Model:**
```
┌──────────────────┐      WebSocket (wss://)      ┌──────────────────┐
│  Windows Master  │◄────────────────────────────►│  Linux Slave 1   │
│  (GUI - Desktop) │                              │  (systemd/VPS)   │
└──────────────────┘                              └──────────────────┘
         │                                                 │
         │              ┌──────────────────┐               │
         └─────────────►│  Linux Slave 2   │◄──────────────┘
                        │  (systemd/VPS)   │
                        └──────────────────┘
                                 │
                        ┌──────────────────┐
                        │  Linux Slave N   │
                        │  (systemd/VPS)   │
                        └──────────────────┘
```

**Recommendation:** Release v3.6.5 with testing + env var config before starting v3.7.0 development.

---

*Document Version: 1.2*
*Created: 2025-12-22*
*Updated: 2025-12-22 - Added Linux deployment, zero-touch management, smart RDP detection*
*Author: Claude Code Analysis*
